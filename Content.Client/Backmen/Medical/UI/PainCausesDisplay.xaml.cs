using System.Linq;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Shared.Maths;
using Robust.Shared.Localization;

namespace Content.Client.Backmen.Medical.UI;

[GenerateTypedNameReferences]
public sealed partial class PainCausesDisplay : Control
{
    private const float MaxPainValue = 250f;
    private const float CriticalThreshold = 200f;
    private const float MediumThreshold = 100f;

    public PainCausesDisplay()
    {
        RobustXamlLoader.Load(this);
    }

    public void UpdatePainCauses(Dictionary<string, float>? painCauses)
    {
        RootContainer.RemoveAllChildren();

        if (painCauses == null || painCauses.Count == 0)
        {
            Visible = false;
            return;
        }

        Visible = true;

        var painTitle = new Label
        {
            Text = Loc.GetString("health-analyzer-window-pain-causes-text"),
            Margin = new Thickness(0, 0, 0, 5),
        };
        RootContainer.AddChild(painTitle);

        var painCausesSorted = painCauses
            .OrderByDescending(p => p.Value)
            .ToDictionary(x => x.Key, x => x.Value);

        foreach (var (identifier, value) in painCausesSorted)
        {
            var painCauseContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Vertical,
                Margin = new Thickness(0, 5, 0, 5),
            };

            var labelContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                HorizontalExpand = true,
            };

            var painCauseLabel = new Label
            {
                Text = GetPainCauseName(identifier),
                HorizontalExpand = true,
            };
            labelContainer.AddChild(painCauseLabel);

            var valueLabel = new Label
            {
                Text = $"{value:F1}",
                HorizontalAlignment = Control.HAlignment.Right,
            };
            labelContainer.AddChild(valueLabel);

            painCauseContainer.AddChild(labelContainer);

            var painBar = new ProgressBar
            {
                MinValue = 0,
                MaxValue = MaxPainValue,
                Value = Math.Min(value, MaxPainValue),
                HorizontalExpand = true,
                SetHeight = 20,
                Margin = new Thickness(0, 2, 0, 0),
            };

            // Set color based on pain level
            painBar.ForegroundStyleBoxOverride = new StyleBoxFlat
            {
                BackgroundColor = GetPainColor(value)
            };

            painCauseContainer.AddChild(painBar);

            RootContainer.AddChild(painCauseContainer);
        }
    }

    private static string GetPainCauseName(string identifier)
    {
        return identifier switch
        {
            "WoundPain" => Loc.GetString("health-analyzer-window-pain-cause-wound-pain"),
            "Suffocation" => Loc.GetString("health-analyzer-window-pain-cause-suffocation"),
            "Bloodloss" => Loc.GetString("health-analyzer-window-pain-cause-bloodloss"),
            "DeathThreshold" => Loc.GetString("health-analyzer-window-pain-cause-death-threshold"),
            "Suicide" => Loc.GetString("health-analyzer-window-pain-cause-suicide"),
            _ => identifier, // Fallback to identifier if no localization found
        };
    }

    /// <summary>
    /// Gets the color for a pain bar based on the pain value.
    /// 0-100: Green to Yellow
    /// 100-200: Yellow to Orange to Red
    /// 200-250: Red to Dark Red
    /// 250+: Dark Red/Black
    /// </summary>
    private static Color GetPainColor(float value)
    {
        if (value >= MaxPainValue)
        {
            // Death threshold - dark red/black
            return new Color(0.3f, 0f, 0f, 1f);
        }
        else if (value >= CriticalThreshold)
        {
            // Critical - red to dark red
            var ratio = (value - CriticalThreshold) / (MaxPainValue - CriticalThreshold);
            return Color.InterpolateBetween(new Color(1f, 0f, 0f, 1f), new Color(0.5f, 0f, 0f, 1f), ratio);
        }
        else if (value >= MediumThreshold)
        {
            // Medium - yellow to orange to red
            var ratio = (value - MediumThreshold) / (CriticalThreshold - MediumThreshold);
            return Color.InterpolateBetween(new Color(1f, 1f, 0f, 1f), new Color(1f, 0f, 0f, 1f), ratio);
        }
        else
        {
            // Low - green to yellow
            var ratio = value / MediumThreshold;
            return Color.InterpolateBetween(new Color(0f, 1f, 0f, 1f), new Color(1f, 1f, 0f, 1f), ratio);
        }
    }
}
