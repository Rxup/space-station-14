uniform sampler2D SCREEN_TEXTURE;
uniform sampler2D LIGHT_TEXTURE;
uniform highp float Zoom;

uniform highp float CircleRadius;
uniform highp float CircleMinDist;
uniform highp float CirclePow;
uniform highp float CircleMax;
uniform highp float CircleMult;
uniform highp float FalloffClampMin;
uniform highp float FalloffClampMax;
uniform highp float FalloffStrength;
uniform highp float FalloffPow;
uniform highp float MaxBrightness;
uniform highp float SunBrightnessCap;

highp float calculateCircleGradient(highp vec2 aspect, highp vec2 uv, highp float circleMax, highp float radius, highp float minDist, highp float power) {
    highp vec2 center = vec2(0.5, 0.5); // Assuming screen center is (0.5, 0.5)
    highp vec2 uv_centered = (uv * aspect) - (center * aspect);
    highp float dist = length(uv_centered);
    highp float gradient = clamp((dist - minDist) / (radius - minDist), 0.0, 1.0);
    return circleMax * pow(1.0 - gradient, power);
}

highp float calculateLuminance(highp vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}


void fragment() {
    COLOR = zTextureSpec(SCREEN_TEXTURE, Pos);
    highp vec2 aspect = vec2(1.0 / SCREEN_PIXEL_SIZE.x, 1.0 / SCREEN_PIXEL_SIZE.y);
    highp float actualZoom = Zoom;

    highp float circle = calculateCircleGradient(aspect, Pos, CircleMax, CircleRadius / actualZoom, CircleMinDist / actualZoom, CirclePow);
    circle *= CircleMult;
    highp float totalCircleIntensity = clamp(circle, FalloffClampMin, FalloffClampMax);

    highp vec3 lightsampleraw = texture2D(LIGHT_TEXTURE, Pos).rgb;

    highp float graylight = max(calculateLuminance(lightsampleraw) - (totalCircleIntensity * FalloffStrength), 0.0);

    graylight = min(graylight, SunBrightnessCap);

    highp vec3 lightsample = lightsampleraw * vec3(graylight);

    COLOR.rgb += clamp(lightsample, vec3(0.0), vec3(MaxBrightness));
}
